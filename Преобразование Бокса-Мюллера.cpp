/********************************************************************************
 *      К У Р С О В А Я   Р А Б О Т А   З А   3   С Е М Е С Т Р   С  +  +       *
 *------------------------------------------------------------------------------*
 * Project Type  : Win64 Console Application                                    *
 * Project Name  : Box Muller transform                                         *
 * File Name     : Преобразование Бокса-Мюллера. CPP                            *
 * Programmer    : Викулов Д.Г.                                                 *
 * Modifyed By   :                                                              *
 * Created       : 15/11/22                                                     *
 * Last Revision : 27/12/22                                                     *
 * Comment(s)    : Программа, моделирующая гауссовское распределение с помощью  *
 *                 косинусного преобразования Бокса-Мюллера. Расчёт данных для  *
 *                 гистограмм. Подсчёт статистических характеристик.            *
 ********************************************************************************/

#include <iostream>        // стандартные потоки ввода/вывода
#include <cmath>           // библиотека с математическими функциями
#include <iomanip>         // библиотека с модификатором setw
#include <fstream>         // файловые потоки ввода/вывода
using namespace std;       // используем пространство имён std

/*******************************************************************/
/*            Г Л О Б А Л Ь Н Ы Е   К О Н С Т А Н Т Ы              */
/*******************************************************************/

const double PI = 3.141592653589793;     // глобальная константа числа пи
const float step = 0.5;                  // шаг разбития гистограммы нормального распределения
const float step_ravnomerno = 0.2;       // шаг разбиения для гистограммы равномерных процессов
const char* FNAME = "Result.txt";        // путь к файлу через константный указатель
const char* FNAME_READ = "Number_of pairs.txt";

/*******************************************************************/
/*         Г Л О Б А Л Ь Н Ы Е   Ф А Й Л О В Ы Е   П О Т О К И     */
/*******************************************************************/

ofstream fout;                          // объявление объекта для потокового вывода данных в файл
ifstream fin;                           // объявление объекта для потокового ввода данных из файла

/*******************************************************************/
/*              П Р О Т О Т И П Ы    Ф У Н К Ц И Й                 */
/*******************************************************************/

// удаление динамического массива - вектора
void udalenie(double* mass_raspr);      // указатель на первый элемент динамического массива-вектора 

// вывод сформированного массива результатов преобразования
void pechat_tabl(double* mass_raspr     // указатель на первый элемент динамического массива-вектора 
	           , int number);           // количество элементов в массиве-векторе

// вывод полученной матрицы
void pechat_Matr(double** ppMatr        // указатель первого элемента матрицы указателей
	           , int k);                // количество строк в матрице

//освободить память матрицы
void delete_Matr(double** ppMatr        // указатель на первый элемент матрицы указателей
	           , int k);                // количество строк в матрице

// расчёт нормального распределения преобразованием
void Box_Muller_preobr(double* mass_raspr  // указатель на первый элемент массива преобразования
	                   , double* A         // указатель на первый элемент динамического массива равномерно распределённой СВ
                       , double* B         // указатель на первый элемент динамического массива равномерно распределённой СВ
                       , int number);      // количество элементов, которое необходимо сформировать

// создание равномерно распределённых псевдослучайных чисел
double Ravnomernoe_gen(void);           // функция ничего не принимает

// подсчёт выборочного среднего
double Srednee_znach(double* mass_raspr // указатель на первый элемент динамического массива-вектора 
	             , int number_psevdo);  // количество элементов в массиве-векторе

// подсчёт выборочной дисперсии
double vub_dispers(double* mass_raspr   // указатель на первый элемент динамического массива-вектора 
	           , int number_psevdo      // количество элементов в массиве-векторе
	           , double vub_srednee);   // рассчитанное выборочное среднее

// подсчёт медианы выборки 
void mediana(double* mass_raspr         // указатель на первый элемент динамического массива-вектора
	       , int number_psevdo);        // количество элементов в массиве-векторе

// подсчёт моды выборки
void moda(double* ppMatrA[]             // указатель первого элемента матрицы указателей
	    , int k                         // количество строк матрицы
	    , int columns);                 // количество столбцов матрицы

// расчёт интервалов и величин гистограммы
void gistogramma(double* ppMatrA[]      // указатель первого элемента матрицы указателей
	           , int& k                 // количество строк матрицы
	           , double* mass_raspr     // указатель на первый элемент динамического массива-вектора
	           , int number_psevdo      // количество элементов в массиве-векторе
               , double vub_srednee);   // расcчитанное выборочное среднее

// расчёт интервалов и величин гистограммы
void gistogramma_ravnomerno(double* ppMatrA[]   // указатель первого элемента матрицы указателей
                          , int& k              // количество строк матрицы для изменения
	                      , double* mass_raspr  // указатель на первый элемент динамического массива-вектора
	                      , int number_psevdo); // количество элементов в массиве-векторе

// сортировка слиянием по возрастанию
void Merge_sort_vozr(double *mass_raspr // указатель на первый элемент динамического массива-вектора
	               , int begin          // начало динамического массива-вектора
	               , int end);          // конец динамического массива-вектора

// "Властвование" - сливание массивов для Merge_sort_vozr
void Merge_vozr(double * mass_raspr     // указатель на первый элемент динамического массива-вектора
	          , int begin               // начало динамического массива-вектора
	          , int middle              // середина динамического массива-вектора
	          , int end);               // конец динамического массива-вектора

// расчёт теоретической плотности нормального распределения
void teor_plotnost_norm(double vub_srednee      // раcсчитанное выборочное среднее
	                  , double vub_disp         // расcчитанная выборочная дисперсия
	                  , int number_psevdo       // количество элементов в выборке
	                  , double* ppMatrA[]       // указатель первого элемента матрицы указателей
	                  , int k);                 // количество строк в матрице указателей

// расчёт теоретической плотности равномерного распределения
void teor_plotnost_ravn(double vub_disp         // расcчитанная выборочная дисперсия
	                  , int number_psevdo       // количество элементов в выборке
	                  , double* ppMatrA[]       // указатель первого элемента матрицы указателей
	                  , int k);                 // количество строк в матрице указателей

// расчет функции псевдослучайных процессов
void pract_raspr(double* ppMatrA[]      // указатель первого элемента матрицы указателей
	           , int k);                // количество строк в матрице указателей

// расчет теоретической функции гауссовского процесса
void teor_raspr_norm(double vub_srednee // раcсчитанное выборочное среднее
	               , double vub_disp    // раcсчитанная выборочная дисперсия
	               , double* ppMatrA[]  // указатель первого элемента матрицы указателей
	               , int k);            // количество строк в матрице указателей

// расчет теоретической функции равномерного процесса
void teor_raspr_ravnom(double* ppMatrA[]        // указатель первого элемента матрицы указателей
	                 , int k);                  // количество строк в матрице указателей

/**************************************************************/
/*            О С Н О В Н А Я   П Р О Г Р А М М А             */
/**************************************************************/
int main()
{
	system("color F0");                 // делаем консоль светлой
	setlocale(LC_ALL, "Rus");           // подключаем русский язык
	system("cls");                      // чистим консоль перед выводом
	int number_psevdo;                  // число элементов выборки
	double vub_srednee_fi;              // выборочное среднее выборки равномерной fi
	double vub_srednee_R;               // выборочное среднее выборки равномерной R
	double vub_srednee;                 // выборочное среднее выборки нормального распределения
	double vub_disp_fi;                 // выборочная дисперсия выборки равномерной fi
	double vub_disp_R;                  // выборочная дисперсия выборки равномерной R
	double vub_disp;                    // выборочная дисперсия выборки нормального распределения
	int k;                              // наибольшее количество интервалов гистограммы и далее-реальное
	int columns = 7;                    // количество колонок в матрице для гистограмм
	int begin;                          // начало динамического массива-вектора
	int end;                            // конец динамического массива -вектора
	double* mass_raspr = NULL;          // указатель на динамический массив преобразования. Записываем 0, чтобы указатель не был диким 
	double* fi = NULL;                  // указатель на динамический массив равномерно распределённой СВ. Записываем 0, чтобы указатель не был диким   
	double* R = NULL;                   // указатель на динамический массив равномерно распределённой СВ. Записываем 0, чтобы указатель не был диким
	double** ppMatrA = NULL;            // указатель на матрицу указателей преобразования. Записываем 0, чтобы указатель не был диким
	double** ppMatrfi = NULL;           // указатель на матрицу указателей равномерно распределённой СВ. Записываем 0, чтобы указатель не был диким
	double** ppMatrR = NULL;            // указатель на матрицу указателей равномерно распределённой СВ. Записываем 0, чтобы указатель не был диким
	fin.open(FNAME_READ);               // связываем объект с файлом. Открываем для чтения
	if (!fin.is_open())                 // файл чтения не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить чтение\n";
		fin.close();                    // закрыть файл для чтения
		system("pause");
		return 1;                       // возвращаем значение, соответствующее типу в caller
	}// if (!fin.is_open()) 
	fout.open(FNAME, ios::_Nocreate);   // связываем объект с файлом. Открываем для записи
	if (!fout.is_open())                // файл не найден
	{
		cout << "Файла с таким именем нет. Невозможно осуществить запись\n";
		fout.close();                    // закрыть файл для записи
		system("pause");
		return 2;                        // возвращаем значение, соответствующее типу в caller
	}// if(!fout.is_open())

	cout << "\t\t\t\x1b[35mГАУССОВСКОЕ РАСПРЕДЕЛЕНИЕ С ПОМОЩЬЮ КОСИНУСНОГО ПРЕОБРАЗОВАНИЯ БОКСА-МЮЛЛЕРА\x1b[30m\n\n";
	cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m если Вы хотите напечатать подробно сформированную выборку, вводите количество пар не очень большим!\n\n";
	{
		cout << "Количество пар псевдослучайных чисел, считанное из файла: ";
		fin >> number_psevdo;            // размер массива, введённый пользователем
		if (number_psevdo <=0 )          // если количество элементов не число
		{// выход по ошибке
			cout << "Количество элементов не является числом или вне диапазона!!!";
			cout << "\n\t\t\t\t\tЗ А В Е Р Ш Е Н И Е   П Р О Г Р А М М Ы \n\n";
			system("pause");
			return 3;                    // закончили программу по ошибке
		}//if (number_psevdo <=0)
		cout << number_psevdo << endl << endl;
		mass_raspr = new double[number_psevdo];// ввели количество элементов число - создали массив на нужное количество элементов
		fi = new double[number_psevdo];
		R = new double[number_psevdo];
	}
	// заполняем его числами, полученными в результате преобразования
	Box_Muller_preobr(mass_raspr, fi, R, number_psevdo);    
	char vubor;                          // выбор, хочет ли пользователь печатать сформированные массивы на экран
	cout << "Хотите ли Вы печатать сформированный результат преобразования и массивы равномерных процессов?"<<endl<<"Введите Y или N латиницей : ";
	cin >> vubor;                        // ввод выбора, хочет ли пользователь печатать
	cout << "Вы ввели: " << vubor << endl;  // эхо -печать
	// если пользователь хочет печатать
	if (vubor == 'Y' || vubor == 'y')
	{
		cout << "\n\t\t\t\t \x1b[33mС Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й  fi:\x1b[30m \n";
		fout << "\t\t\t\t С Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й fi: \n";
		// печать сформированного массива преобразования
		pechat_tabl(fi, number_psevdo);
		cout << "\n\t\t\t\t \x1b[33mС Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й  R:\x1b[30m \n";
		fout << "\t\t\t\t С Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й R: \n";
		// печать сформированного массива равномерно распределённой СВ
		pechat_tabl(R, number_psevdo);      
		cout << "\n\t\t\t\t \x1b[33mС Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й:\x1b[30m \n";
		fout << "\t\t\t\t С Ф О Р М И Р О В А Н Н Ы Й   М А С С И В   З Н А Ч Е Н И Й: \n";
		// печать сформированного массива равномерно распределённой СВ
		pechat_tabl(mass_raspr, number_psevdo);    
	}
	// пользователь не хочет печатать сформированные массивы на экран
	else
	{
		// выводим эту информацию на экран и в файл
		cout << "\x1b[34mВы не захотели подробно печатать сформированные выборки\x1b[30m \n\n";
		fout << "Вы не захотели подробно печатать сформированные выборки\n\n";
	}// if (vubor == 'Y' || vubor == 'y')

	cout << "\n\n\t\t\t\t\x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я  fi \x1b[30m \n";
	fout << "\n\n\t\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я  fi \n";
	cout << "\n\x1b[31mПРАВИЛО:\x1b[30m Чтобы найти выборочную среднюю по первичным данным, нужно просуммировать все варианты и разделить полученный результат на объём совокупности.\n\n";
	vub_srednee_fi = Srednee_znach(fi, number_psevdo);        // подсчёт выборочного среднего для массива равномерно распределённой СВ
	cout << "\n\n\n\t\t\t\t \x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я  R \x1b[30m \n";
	fout << "\n\n\t\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я  R \n";
	vub_srednee_R =  Srednee_znach(R, number_psevdo);         // подсчёт выборочного среднего для массива равномерно распределённой СВ
	cout << "\n\n\n\t\t\t \x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я  П Р Е О Б Р А З О В А Н И Я \x1b[30m \n";
	fout << "\n\n\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Г О   С Р Е Д Н Е Г О  Д Л Я   П Р Е О Б Р А З О В А Н И Я \n";
	vub_srednee =  Srednee_znach(mass_raspr, number_psevdo);  // подсчёт выборочного среднего для массива преобразования
	cout << "\n\n\t\t\t\t\x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  fi\x1b[30m \n";
	fout << "\n\n\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  fi \n";
	cout << "\n\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Выборочная дисперсия - среднее арифметическое квадратов отклонений всех вариант выборки от её средней.\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Стандартное отклонение выборки - корень из выборочной дисперсии.\n\n";
	// вызвали функцию, рассчитывающую выборочную дисперсию для массива равномерно распределённой СВ
	vub_disp_fi = vub_dispers(fi, number_psevdo, vub_srednee);
	cout << "\n\n\t\t\t\t\x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  R\x1b[30m \n";
	fout << "\n\n\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  R \n";
	// вызвали функцию, рассчитывающую выборочную дисперсию для массива равномерно распределённой СВ
	vub_disp_R = vub_dispers(R, number_psevdo, vub_srednee);
	cout << "\n\n\t\t\t\x1b[33mР А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  П Р Е О Б Р З О В А Н И Я\x1b[30m \n";
	fout << "\n\n\t\t\t\t\t Р А С Ч Ё Т   В Ы Б О Р О Ч Н О Й   Д И С П Е Р С И И  Д Л Я  П Р Е О Б Р З О В А Н И Я \n";
	// вызвали функцию, рассчитывающую выборочную дисперсию для массива преобразования
	vub_disp = vub_dispers(mass_raspr, number_psevdo, vub_srednee);
	begin = 0;                                 // массивы начинаются с 0-го элемента
	end = number_psevdo - 1;                   // заканчиваются на один элемент меньшим индексом, чем длина
	//отсортировали для расчёта медианы массива равномерно распределённой СВ
	Merge_sort_vozr(fi, begin, end);           // вызвали сортировку слиянием
	//отсортировали для расчёта медианы массива равномерно распределённой СВ
	Merge_sort_vozr(R, begin, end);            // вызвали сортировку слиянием
	//отсортировали для расчёта медианы массива преобразования
	Merge_sort_vozr(mass_raspr, begin, end);   // вызвали сортировку слиянием
	// для расчёта медианы массив должен быть отсортирован
	cout << "\n\n\n\t\t \x1b[33mР А С Ч Ё Т   М Е Д И А Н Ы   В А Р И А Ц И О Н Н О Г О   Р Я Д А   П Р Е О Б Р А З О В А Н И Я\x1b[30m \n";
	fout << "\n\n\n\t\t Р А С Ч Ё Т   М Е Д И А Н Ы   В А Р И А Ц И О Н Н О Г О   Р Я Д А   П Р Е О Б Р А З О В А Н И Я\n";
	// даём ряд определений, необходимых для вычисления медианы
	cout << "\n\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Медиана вариационного ряда - значение, которое делит его на две равные части (по количеству вариант).\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Массив с выборкой должен быть отсортирован.\n\n";
	// рассчитали медиану выборки массива преобразования
	mediana(mass_raspr, number_psevdo);        
	// модифицированная формула корня. Считаем максимальное количество интервалов в гистограмме
	k = 10*sqrt(number_psevdo);      // расчёт количества интервалов с округлением в меньшую сторону из-за типа int.
	{
		int i;                       // для прохода по строкам
		// создаём динамическую матрицу из указателей на строки с учётом того, что мы передавали указатель в функцию. Их k штук для каждого массива
		ppMatrfi = new double* [k];         
		ppMatrR = new double* [k];
		ppMatrA = new double* [k];             
		// идём по всем строкам матрицы 
		for (i = 0; i < k; i++)      // выделение памяти под каждый элемент строки конкретной длины  
		{
			// на каждую строку матрицы указателей выделяем  динамический массив длиной columns
			ppMatrA[i] = new double[columns];  
			ppMatrfi[i] = new double[columns];
			ppMatrR[i] = new double[columns];
		}// for i
	}

	// рассчитываем параметра матрицы и гистограмм
	// расчёт параметров для равномерно распределённой СВ fi
	{
		cout << "\n\n\t\t \x1b[33m     Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А  Д Л Я  fi\x1b[30m \n\n";
		fout << "\n\n\t\t Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А   Д Л Я  fi \n\n";
		gistogramma_ravnomerno(ppMatrfi, k, fi, number_psevdo); // рассчитали интервалы гистограммы для равномерно распределённой СВ
		pechat_Matr(ppMatrfi, k);                               // вывели сформированную матрицу равномерно распределённой СВ
		cout << "\n\x1b[33m  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я  fi\x1b[30m\n\n";
		fout << "\n\x1b  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я  fi\n\n";
		// расcчитываем теоретическую плотность распределения равномерно распределённой fi
		teor_plotnost_ravn(vub_disp_fi, number_psevdo, ppMatrfi, k);
		cout << "\n\n\t\t\x1b[33m  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  fi\x1b[30m\n\n";
		fout << "\n\n\t\t  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  fi\n\n";
		cout << "\x1b[31mПРАВИЛО:\x1b[30m Все значения функции, что правее конца самого левого интервала в гистограмме - имеют нулевой значение функции\n";
		cout << "распределения далее берем крайние значения каждого интервала - за значение на оси X, накапливаем относительные частоты;\nw_n = w[i] + w_n - значение на оси Y\n\n";
		// расчёт псевдослучайного процесса для fi
		pract_raspr(ppMatrfi, k);
		cout << "\n\n\t\x1b[33m  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я   fi\x1b[30m\n\n";
		fout << "\n\n\t  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я   fi";
		cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m расчёт происходит по формуле функции распределения равномерного распределения в тех же точках, что и\nпрактическое;\n\n";
		// расчёт теоретического псевдослучайного процесса для fi
		teor_raspr_ravnom(ppMatrfi, k);
	}
	// расчёт параметров для равномерно распределённой СВ R
	{
		cout << "\n\n\t\t \x1b[33m     Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А  Д Л Я  R\x1b[30m \n\n";
		fout << "\n\n\t\t Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А   Д Л Я  R \n\n";
		gistogramma_ravnomerno(ppMatrR, k, R, number_psevdo);   // рассчитали интервалы гистограммы для равномерно распределённой СВ R
		pechat_Matr(ppMatrR, k);                                // вывели сформированную матрицу равномерно распределённой СВ R
		cout << "\n\x1b[33m  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я  R\x1b[30m\n\n";
		fout << "\n\x1b  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я  R\n\n";
		// расcчитываем теоретическую плотность распределения равномерно распределённой R
		teor_plotnost_ravn(vub_disp_R, number_psevdo, ppMatrR, k);
		cout << "\n\n\t\t\x1b[33m  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  R\x1b[30m\n\n";
		fout << "\n\n\t\t  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  R\n\n";
		cout << "\x1b[31mПРАВИЛО:\x1b[30m Все значения функции, что правее конца самого левого интервала в гистограмме - имеют нулевой значение функции\n";
		cout << "распределения алее берем крайние значения каждого интервала - за значение на оси X, накапливаем относительные частоты;\nw_n = w[i] + w_n - значение на оси Y\n\n";
		// расчёт псевдослучайного процесса для R
		pract_raspr(ppMatrR, k);
		cout << "\n\n\t\x1b[33m  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я   R\x1b[30m\n\n";
		fout << "\n\n\t  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я   R";
		cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m расчёт происходит по формуле функции распределения равномерного распределения в тех же точках, что и\nпрактическое;\n\n";
		// расчёт теоретического псевдослучайного процесса для R
		teor_raspr_ravnom(ppMatrR, k);
	}
	// расчёт параметров для преобразования
	{
		cout << "\n\n \x1b[33m  Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А  Д Л Я  П Р Е О Б Р А З О В А Н И Я\x1b[30m \n\n";
		fout << "\n\n Р А С Ч Ё Т   И Н Т Е Р В А Л Ь Н О Г О   В А Р И А Ц И О Н Н О Г О   Р Я Д А   Д Л Я  П Р Е О Б Р А З О В А Н И Я \n\n";
		// рассчитали интервалы гистограммы для преобразования
		gistogramma(ppMatrA, k, mass_raspr, number_psevdo, vub_srednee);
		// вывели сформированную матрицу преобразования
		pechat_Matr(ppMatrA, k);
		cout << "\n\x1b[33m     Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я \n";
		cout << "\t\t\t\t\t\tП Р Е О Б Р А З О В А Н И Я\x1b[30m \n";
		fout << "\n\n\t\t Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Й   Ф У Н К Ц И И   П Л О Т Н О С Т И   Р А С П Р Е Д Е Л Е Н И Я   Д Л Я \n\n";
		fout << "\t\t\t\t\t\tП Р Е О Б Р А З О В А Н И Я\n";
		// рассчитываем теоретическую плотность распределения преобразования
		teor_plotnost_norm(vub_srednee, vub_disp, number_psevdo, ppMatrA, k);
		cout << "\n\n\t\x1b[33m  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  П Р Е О Б Р А З О В А Н И Я\x1b[30m\n\n";
		fout << "\n\n\t  Р А С Ч Ё Т   П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я  П Р Е О Б Р А З О В А Н И Я\n\n";
		cout << "\x1b[31mПРАВИЛО:\x1b[30m Все значения функции, что правее конца самого левого интервала в гистограмме - имеют нулевой значение функции\n";
		cout << "распределения алее берем крайние значения каждого интервала - за значение на оси X, накапливаем относительные частоты;\nw_n = w[i] + w_n - значение F(X)\n\n";
		// расчёт псевдослучайного процесса для преобразования
		pract_raspr(ppMatrA, k);
		cout << "\n\n\t\x1b[33m  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я\n\t\t\t\t\t\t  П Р Е О Б Р А З О В А Н И Я\x1b[30m\n\n";
		fout << "\n\n\t  Р А С Ч Ё Т   Т Е О Р Е Т И Ч Е С К О Г О  П С Е В Д О С Л У Ч А Й Н О Г О   П Р О Ц Е С С А   Д Л Я\n\t\t\t\t\t\t  П Р Е О Б Р А З О В А Н И Я\n\n";
		cout << "\x1b[31mЗАМЕЧАНИЕ:\x1b[30m расчёт происходит по формуле функции распределения гауссовского распределения в тех же точках, что и\nпрактическое;\n\n";
		// расчёт теоретического псевдослучайного процесса для преобразования
		teor_raspr_norm(vub_srednee, vub_disp, ppMatrA, k);
	}
	cout << "\n\n\t\t \x1b[33m  Р А С Ч Ё Т   М О Д Ы   В А Р И А Ц И О Н Н О Г О   Р Я Д А  П Р Е О Б Р А З О В А Н И Я\x1b[30m \n\n";
	fout << "\n\n\t\t Р А С Ч Ё Т   М О Д Ы   В А Р И А Ц И О Н Н О Г О   Р Я Д А  П Р Е О Б Р А З О В А Н И Я\n\n";
	cout << "\n\x1b[31mПРАВИЛО:\x1b[30m Чтобы найти моду, нужно найти модальный интервал(с максимальной частотой) и воспользоваться формулой: \n";
	cout << "M = X[0]+(n[M]-n[M-1])/((n[M]-n[M-1]) + (n[M]-n[M+1]))\n\n";
	moda(ppMatrA, k, columns);                   // подсчитали моду результата преобразования
	delete_Matr(ppMatrfi, k);                    // отработали - удалили матрицу
	delete_Matr(ppMatrR, k);                     // отработали - удалили матрицу
	delete_Matr(ppMatrA, k);                     // отработали - удалили матрицу
	udalenie(fi);                                // отработали - удалили массив
	udalenie(R);                                 // отработали - удалили массив
	udalenie(mass_raspr);                        // отработали - удалили массив
	fin.close();                                 // закрыть файл считывания
	system("pause");
	return 0;                                    // вернули обещанное значение в caller
}

/*-----------------------------------------------------------------------------*/
/* удаление динамического массива           */
/*------------------------------------------*/
void udalenie(double* mass_raspr)              // указатель на первый элемент динамического массива-вектора
{
	delete[] mass_raspr;                       // удалили динамический массив-вектор
	return;                                    // возвращаем обещанное значение в caller
}// udalenie()


/*--------------------------------------------------------------------------*/
/* печать сформированного массива в таблице */
/*------------------------------------------*/
void pechat_tabl(double* mass_raspr     // указатель на первый элемент динамического массива-вектора 
	           , int number)            // количество элементов в массиве-векторе

{
	int j;                              // для прохода по элементам массива
	setlocale(0, "C");                  // отключаем русский язык
	cout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;          // вывод верхних квадратных скобок
	fout << (char)218 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)191;
	for (j = 0; j < number; j++)        // идем по всем элементам массива, используя адресную арифметику
	{// выводим элемент массива с округление до трёх цифр после запятой, боковые скобки и номер элемента
		cout << "\n" << char(179) << setw(17) << setfill(' ') << round(* (mass_raspr + j)*1000)/1000 << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;
		// выводим в файл значение сформированного массива и его номер
		fout << "\n" << char(179) << setw(17) << setfill(' ') << round(*(mass_raspr + j) * 1000) / 1000 << setw(17) << setfill(' ') << char(179) << setw(6) << setfill(' ') << "n = " << j + 1;;
	}// for j
	cout << '\n';
	fout << '\n';
	cout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;  // вывод нижних квадратных скобок
	fout << (char)192 << (char)196 << (char)196 << setw(30) << setfill(' ') << (char)196 << (char)196 << (char)217 << endl;
	setlocale(LC_ALL, "Rus");          // подключаем русский язык
	// иначе - пользователь не захотел печатать
	return;                            // напечатали - вернулись в caller
}//pechat_tabl()


/*--------------------------------------------------------------------------*/
/* вывод полученной матрицы  */
/*---------------------------*/
void pechat_Matr(double** ppMatr  // указатель первого элемента матрицы указателей
	           , int k)           // количество строк в матрице
{
	setlocale(0, "C");            // отключаем русский язык
	// выводим шапку таблицы
	// верхняя строка шапки
	fout << char(218) << setw(25) << setfill((char)196) << (char)194 << setw(15) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)191 << endl << (char)179;
	cout << char(218) << setw(25) << setfill((char)196) << (char)194 << setw(15) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)194 << setw(13) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки с разделителями
	fout << "       intervals        " << (char)179 << "     X[i]     " << (char)179 << "    n[i]    " << (char)179 << "   n[i]/h   " << (char)179 << "    w[i]    " << (char)179 << "   w[i]/h   ";
	cout << "       intervals        " << (char)179 << "     X[i]     " << (char)179 << "    n[i]    " << (char)179 << "   n[i]/h   " << (char)179 << "    w[i]    " << (char)179 << "   w[i]/h   ";
	// нижняя строка шапки
	fout << (char)179 << endl << (char)195 << setw(25) << setfill((char)196) << (char)197 << setw(15) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)180 << endl;
	cout << (char)179 << endl << (char)195 << setw(25) << setfill((char)196) << (char)197 << setw(15) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)180 << endl;
	// выводим элементы матрицы соответственно их колонкам на экран и в файл с округлением до трёх цифр после запятой
	for (int i = 0; i < k; i++)
	{
		fout << (char)179 << setw(11) << setfill(' ') << round(ppMatr[i][0]*1000)/1000 << setw(1) << setfill(' ') << char(179) << setw(10) << setfill(' ') << round(ppMatr[i][1]*1000)/1000 << setw(3) << setfill(' ') << (char)179 << setw(12) << setfill(' ') << round(ppMatr[i][2]*1000)/1000 << setw(3) << setfill(' ') << (char)179 << setw(7) << setfill(' ') << round(ppMatr[i][3]*1000)/1000 << setw(6) << setfill(' ') << (char)179 << setw(10) << setfill(' ') << round(ppMatr[i][4]*1000)/1000 << setw(3) << setfill(' ') << (char)179 << setw(10) << setfill(' ') << round(ppMatr[i][5]*1000)/1000 << setw(3) << setfill(' ') << (char)179 << setw(12) << setfill(' ') << round(ppMatr[i][6]*1000)/1000 << setw(1) << setfill(' ');
		fout << (char)179 << endl << (char)195 << setw(25) << setfill((char)196) << (char)197 << setw(15) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)180 << endl;
		cout << (char)179 << setw(11) << setfill(' ') << round(ppMatr[i][0] * 1000) / 1000 << setw(1) << setfill(' ') << char(179) << setw(10) << setfill(' ') << round(ppMatr[i][1] * 1000) / 1000 << setw(3) << setfill(' ') << (char)179 << setw(12) << setfill(' ') << round(ppMatr[i][2] * 1000) / 1000 << setw(3) << setfill(' ') << (char)179 << setw(7) << setfill(' ') << round(ppMatr[i][3] * 1000) / 1000 << setw(6) << setfill(' ') << (char)179 << setw(10) << setfill(' ') << round(ppMatr[i][4] * 1000) / 1000 << setw(3) << setfill(' ') << (char)179 << setw(10) << setfill(' ') << round(ppMatr[i][5] * 1000) / 1000 << setw(3) << setfill(' ') << (char)179 << setw(12) << setfill(' ') << round(ppMatr[i][6] * 1000) / 1000 << setw(1) << setfill(' ');
		cout << (char)179 << endl << (char)195 << setw(25) << setfill((char)196) << (char)197 << setw(15) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)197 << setw(13) << setfill((char)196) << (char)180 << endl;
	}// for i
	setlocale(LC_ALL, "Rus");     // подключаем русский язык
	return;                       // напечатали - вернулись в caller
}// pechat_Matr()


/*--------------------------------------------------------------------------*/
/* освободить память матрицы */
/*---------------------------*/
void delete_Matr(double** ppMatr        // указатель на первый элемент матрицы указателей
	           , int k)                 // количество строк в матрице
{
	int i;                              // счётчик
	//освобождение памяти в обратном порядке
	for (i = 0; i < k; i++)
	{
		delete[] ppMatr[i];             // удаляем строки (массивы)
	}// for i
	delete[] ppMatr;	                // удаляем массив указателей на строки
	return;                             // удалили - вернулись в caller
}// delete_Matr()


/*--------------------------------------------------------------------------*/
/* расчёт нормального распределения преобразованием  */
/*---------------------------------------------------*/
void Box_Muller_preobr(double* mass_raspr  // указатель на первый элемент массива преобразования
	                 , double* A           // указатель на первый элемент динамического массива равномерно распределённой СВ
	                 , double* B           // указатель на первый элемент динамического массива равномерно распределённой СВ
	                 , int number)         // количество элементов, которое необходимо сформировать
{
	int i;                             // счётчик для заполнения
	double fi;                         // независимая случайная величина, равномерно распределённая на интервале (0;1]
	double R;                          // независимая случайная величина, равномерно распределённая на интервале (0;1]
	double norm;                       // число, полученное в результате косинусного преобразования
	for (i = 0; i < number; i++)
	{
		fi = Ravnomernoe_gen();        // сгенерировали через функцию первое псевдослучайное число
		R = Ravnomernoe_gen();         // сгенерировали через функцию второе псевдослучайное число
		A[i] = fi;                     // сохранили значение fi в массив
		B[i] = R;                      // сохранили значение R в массив
        // рассчитали по формуле независимую случайную величину, распределённую нормально по формуле Бокса-Мюллера
		norm = cos(2 * PI * R) * sqrt(-2 * log(fi));
		// положили вычисленную величину в массив
		mass_raspr[i] = norm;
	}// for i
	return;
}// Box_Muller_preobr()


/*----------------------------------------------------------------------------------*/
/* создание  равномерно распределённых псевдослучайных чисел */
/*------------------------------------------------------------*/
double Ravnomernoe_gen(void)           // функция ничего не принимает
{
	double ravnomerno;                 // очередное равномерно распределённое псевдослучайное число
	// RAND_MAX = 32767
	ravnomerno = (rand() + 1) / (double(RAND_MAX) + 1); // начинается не с 0. Самое минимальное число, которое может получиться в выборке: 1/32768 
	return ravnomerno;                 // вернули вычисленную величину в caller в функцию преобразования
}// Ravnomernoe_gen()


/*--------------------------------------------------------------------------*/
/* подсчёт выборочного среднего */
/*------------------------------*/
double Srednee_znach(double* mass_raspr   // указатель на первый элемент динамического массива-вектора 
                   , int number_psevdo)   // количество элементов в массиве-векторе
{
	double vub_srednee = 0;               // выборочное среднее
	int i;                                // для прохода в цикле по массиву выборки
	// идём по всем элементам массива
	for (i = 0; i < number_psevdo; i++)
	{
		// вычисляем сумму всех элементов выборки
		vub_srednee = vub_srednee + mass_raspr[i];
	}// for i
	// выводим на экран вспомогательные величины для формулы
	cout << "Сумма вариант: " << vub_srednee<<';' << endl;
	cout << "Объём совокупности: " << number_psevdo<<';' << endl;
	// выводим в файл вспомогательные величины для формулы
	fout << "Сумма вариант: " << vub_srednee << ';' << endl;
	fout << "Объём совокупности: " << number_psevdo << ';' << endl;
	// делим накопленную сумму выборки на количество элементов выборки
	vub_srednee = vub_srednee / number_psevdo;
	// вывод на экран выборочного среднего
	cout << "Выборочное среднее для данной выборки: " << vub_srednee << ';' << endl;
	// вывод в файл выборочного среднего
	fout << "Выборочное среднее для данной выборки: " << vub_srednee << ';' << endl;
	return vub_srednee;                   // подсчитали выборочное среднее - вернули его в caller
}// Srednee_znach()


/*--------------------------------------------------------------------------*/
/* подсчёт выборочной дисперсии */
/*------------------------------*/
double vub_dispers(double* mass_raspr     // указатель на первый элемент динамического массива-вектора 
	             , int number_psevdo      // количество элементов в массиве-векторе
	             , double vub_srednee)    // рассчитанное ранее выборочное среднее
{
	double disp = 0;                    // переменная, хранящая значение выборочной дисперсии
	double standart_otkl = 0;           // переменная, хранящая значение среднеквадратичного выборочного отклонения
	int i;                              // для цикла
	char vubor;                         // выбор пользователя, хочет ли печатать
	cout << "Хотите ли Вы выводить подробно все квадраты отклонений? Введите Y или N латиницей: ";
	cin >> vubor;                       // ввод пользователем выбора печати
	// эхо-печать
	cout << "Вы ввели: " << vubor << endl;
	// если пользователь хочет печатать квадраты отклонений в таблице
	if (vubor == 'Y' || vubor == 'y')
	{
		setlocale(0, "C");              // отключаем русский язык
		// печатаем верхнюю часть шапки таблицы
		cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
		// печатаем заполнение шапки таблицы
		cout << "      X[i]      " << (char)179 << "   (X[i] - X_sr)^2    ";
		// печатаем нижнюю часть шапки таблицы
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		// выводим элемент в ячейке и его квадрат отклонения в соседней
		for (i = 0; i < number_psevdo; i++)
		{
			// выводим значение элемента массива и квадрат отклонения
			cout << (char)179 << setw(14) << setfill(' ') << round(mass_raspr[i]*1000)/1000 << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((mass_raspr[i] - vub_srednee)*1000)/1000 << setw(7) << setfill(' ');
			// печатаем строку под очередным выводом в таблице
			cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
			// накапливаем сумму квадратов отклонений
			disp = disp + (mass_raspr[i] - vub_srednee) * (mass_raspr[i] - vub_srednee);
		}// for i
		setlocale(LC_ALL, "Rus");       // подключаем русский язык
	}
	// пользователь не хочет печатать таблицу
	else
	{
		// пишем об этом на экране и в файле
		cout << "\x1b[34mВы не захотели подробно печатать квадраты отклонений.\x1b[30m \n\n";
		fout << "Вы не захотели подробно печатать квадраты отклонений. \n\n";
		// проделываем то же накопление квадратов отклонений в этом случае
		for (i = 0; i < number_psevdo; i++)
		{
			// накапливаем сумму квадратов отклонений
			disp = disp + (mass_raspr[i] - vub_srednee) * (mass_raspr[i] - vub_srednee);
		}// for i
	}// if (vubor == 'Y' || vubor == 'y')
	// выводим сумму квадратов отклонений
	cout << "Сумма квадратов отклонений: " << disp << ';' << endl;
	fout << "Сумма квадратов отклонений: " << disp << ';' << endl;
	// делим сумму квадратов отклонений на количество элементов выборки - получили выборочную дисперсию
	disp = disp / number_psevdo;
	// корень из дисперсии - стандартное отклонение
	standart_otkl = sqrt(disp);
	// выводим на экран и в файл полученную выборочную дисперсию и стандартное отклонение
	cout << "Выборочная дисперсия для данной выборки: " << disp<<';' << endl;
	cout << "Стандартное отклонение: " << standart_otkl << ';' << endl;
	fout << "Выборочная дисперсия для данной выборки: " << disp << ';' << endl;
	fout << "Стандартное отклонение: " << standart_otkl << ';' << endl;
	return disp;                             // подсчитали отклонение и выборочную дисперсию - вернули её в caller
}// vub_dispers()


/*--------------------------------------------------------------------------*/
/* подсчёт медианы выборки  */
/*--------------------------*/
void mediana(double* mass_raspr         // указатель на первый элемент динамического массива-вектора
	       , int number_psevdo)         // количество элементов в массиве-векторе
{
	// если количество элементов выборки - нечётное
	if (number_psevdo % 2 != 0)
	{
		// медиана будет целым числом. Элемент, делящий массив на две части
		int mediana = 0;
		// медиана = n/2
		mediana = number_psevdo / 2;
		// выводим на экран промежуточные значения и саму медиану
		cout << "\nКоличество чисел выборки " << number_psevdo << " - нечётное число. Делим её объём пополам и округляем в большую сторону\n";
		cout << "Индекс медианы выборки: " << mediana<<';' << endl;
		cout << "Значение медианы: " << mass_raspr[mediana]<<';';
		// выводим в файл промежуточные значения и саму медиану
		fout << "\nКоличество чисел выборки " << number_psevdo << " - нечётное число. Делим её объём пополам и округляем в большую сторону\n";
		fout << "Индекс медианы выборки: " << mediana << ';' << endl;
		fout << "Значение медианы: " << mass_raspr[mediana] << ';';
		return;                         // подсчитали медиану - вернулись в caller
	}// if (number_psevdo % 2 != 0)
	// количество элементов выборки - четная. Медиана равна среднему от двух серединных элементов
	double mediana = 0;
	// выводим на экран промежуточные значения
	cout << "\nКоличество чисел выборки " << number_psevdo << " - чётное число. Делим её объём пополам: "<<number_psevdo/2<<" \n";
	cout << "Берём среднее арифметическое " << number_psevdo / 2 << " и следующего за ним элемента;\n";
	// выводим в файл промежуточные значения
	fout << "\nКоличество чисел выборки " << number_psevdo << " - чётное число. Делим её объём пополам: " << number_psevdo / 2 << " \n";
	fout << "Берём среднее арифметическое " << number_psevdo / 2 << " и следующего за ним элемента;\n";
	// считаем медиану выборки как среднее арифметическое двух её центральных элементов
	mediana = (mass_raspr[(number_psevdo / 2) - 1]+mass_raspr[(number_psevdo / 2)])/2;
	// выводим на экран саму медиану
	cout << "Значение медианы: " << mediana<<';';
	// выводим в файл саму медиану
	fout << "Значение медианы: " << mediana << ';';
	return;                             // подсчитали медиану - вернулись в caller
}// mediana()


/*--------------------------------------------------------------------------*/
/* расчёт интервалов и величин гистограммы  */
/*------------------------------------------*/
void gistogramma(double* ppMatrA[]      // указатель первого элемента матрицы указателей
	           , int& k                 // количество строк матрицы
	           , double* mass_raspr     // указатель на первый элемент динамического массива-вектора
	           , int number_psevdo      // количество элементов в массиве-векторе
	           , double vub_srednee)    // рассчитанное выборочное среднее
{
	// массив изначально отсортирован
	int i;                              // для цикла
	double soxr = 0;                    // хранение промежуточного значения 
	double start = mass_raspr[0];       // наименьший элемент массива - элемент с индексом 0. Начало диапазона рассмотрения
	// наибольший элемент массива - последний элемент. Конец диапазона рассмотрения
	double end = mass_raspr[number_psevdo - 1];
	// количество элементов, попавших в тот или иной интервал
	int chislo = 0;
	// в идеально построенной выборке для нормального распределения - ноль. Считаем центральный интервал, отклоняясь на половину шага от нуля в плюс и минус
	double minus = round(vub_srednee) - step / 2;
	double kol_vo_h;                    // плотность частот
	double w;                           // относительные частоты
	double wi_h;                        // плотность относительных частот
	k = 0;                              // для движения по матрице
	// двигаемся в последний интервал для отрицательной части
	cout << "Минимум: " << start << endl;
	cout << "Максимум: " << end << endl;
	fout << "Минимум: " << start << endl;
	fout << "Максимум: " << end << endl;
	// идём от 0 до наименьшего элемента массива. Считаем начало самого левого интервала
	while (minus > start)
	{
		// движение с шагом step
		minus = minus - step;
	}// while
	// если модуль начала левого интервала меньше, чем самое большое значение элемента массива. Делаем так, чтобы гистограмма начиналась и заканчивалась равными по модулю значениями
	if (abs(minus) < end)
	{
		// сдвигаем ещё раз начало
		minus = minus - step;
	}// if
	// запоминаем начало первого интервала гистограммы
	soxr = minus;
	// ищем количество значений выборки, попавших в интервал. Идём по отрицательной части
	while (minus <= round(vub_srednee) - step / 2)
	{
		// идём по всем элементам массива
		for (i = 0; i < number_psevdo; i++)
		{
			// элемент попал в интервал
			if (minus <= mass_raspr[i] && mass_raspr[i] < minus + step)
			{
				// увеличиваем число элементов в этом интервале
				chislo = chislo + 1;
			}// if
		}// for
		// запоминаем начало интервала в 0-ом стролбе матрицы k-ой строки
		ppMatrA[k][0] = minus;
		// запоминаем конец интервала в 1-ом столбце матрицы k-ой строки
		ppMatrA[k][1] = minus + step;
		// запоминаем середину интервала в 2-ом столбце матрицы k-ой строки
		ppMatrA[k][2] = (ppMatrA[k][0] + ppMatrA[k][1]) / 2;
		// запоминаем количество элементов в интервале в 3-ом столбце матрицы k-ой строки
		ppMatrA[k][3] = chislo;
		// расчёт плотности частот как частное количества элементов, попавших в интервал и длины интервала
		kol_vo_h = chislo / step;
		// запоминаем количество элементов в интервале в 4-ом столбце матрицы k-ой строки
		ppMatrA[k][4] = kol_vo_h;
		// сдвигаемся на строку в матрице
		k = k + 1;
		// сдвигаемся на следующий интервал
		minus = minus + step;
		// в новом интервале число элементов 0
		chislo = 0;
	}// while
	// далее идём по положительной части массива, начиная со значения, на котором остановились
	double plus = minus;
	// считаем правую границу гистограммы
	while (plus < end)
	{
		// сдвигаемся на значение step
		plus = plus + step;
	}// while
	// если правая граница интервала получилась меньше, чем левая
	while (plus < abs(soxr))
	{
		// увеличиваем границу правого интервала на step
		plus = plus + step;
	}// while
	chislo = 0;
	cout << "X[i] - середины интервалов. Вычисляются путем вычитания из правого конца интервала левого и делением результата на 2.\n";
	// ищем количество значений выборки, попавших в интервал. Идём по положительной части
	while (minus < plus)
	{
		// идём по всем элементам массива
		for (i = 0; i < number_psevdo; i++)
		{
			// элемент попал в интервал
			if (minus <= mass_raspr[i] && mass_raspr[i] < minus+ step)
			{
				// увеличиваем число элементов в этом интервале
				chislo = chislo + 1;
			}// if
		}// for
		// запоминаем начало интервала в 0-ом стролбце матрицы k-ой строки
		ppMatrA[k][0] = minus;
		// запоминаем конец интервала в 1-ом столбце матрицы k-ой строки
		ppMatrA[k][1] = minus + step;
		// запоминаем середину интервала в 2-ом столбце матрицы k-ой строки
		ppMatrA[k][2] = (ppMatrA[k][0] + ppMatrA[k][1]) / 2;
		// запоминаем количество элементов в интервале в 3-ом столбце матрицы k-ой строки
		ppMatrA[k][3] = chislo;
		// расчёт плотности частот как частное количества элементов, попавших в интервал и длины интервала
		kol_vo_h = chislo / step;
		// запоминаем плотности частот элементов в интервале в 4-ом столбце матрицы k-ой строки
		ppMatrA[k][4] = kol_vo_h;
		// сдвигаемся на строку в матрице
		k = k + 1;
		// сдвигаемся на следующий интервал
		minus = minus + step;
		// в новом интервале число элементов 0
		chislo = 0;
	}// while
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Относительная частота реализации w[i]- отношение числа случаев, в которых встретился данный результат,\n";
	cout << "к общему числу случаев : n[i] / n.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность относительных частот - относительная частота, рассчитанная на единицу ширины интервала: w[i]/h.\n";
	cout << "n[i] -количество вариант, попавших в текущий интервал\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Если варианта попадает на стык интервалов, то её следует относить в правый интервал.\n";
	cout << "Для всех интервалов, кроме последнего.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность частот - частота, рассчитанная на единицу ширины интервала: n[i]/h.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Относительная частота реализации w[i]- отношение числа случаев, в которых встретился данный результат,\n";
	cout << "к общему числу случаев : n[i] / n.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность относительных частот - относительная частота, рассчитанная на единицу ширины интервала: w[i]/h.\n";
	// идём по всем строкам матрицы
	for (i = 0; i < k; i++)
	{
		// считаем относительные частоты
		w = ppMatrA[i][3] / number_psevdo;
		// помещаем их в шестой столбец матрицы
		ppMatrA[i][5] = w;
		// считаем плотность относительных частот
		wi_h = w / step;
		// помещаем её в седьмой столбец матрицы
		ppMatrA[i][6] = wi_h;
	}// for i;
	cout << "\n\x1b[34mСАМА МАТРИЦА:\x1b[30m\n\n";
	fout << "\nСАМА МАТРИЦА:\n\n";
	return;       // заполнили матрицу - вернулись в caller
}// gistogramma()


/*--------------------------------------------------------------------------*/
/* расчёт интервалов и величин гистограммы  */
/*------------------------------------------*/
void gistogramma_ravnomerno(double* ppMatrA[]      // указатель первого элемента матрицы указателей
	                      , int& k                 // количество строк матрицы
	                      , double* mass_raspr     // указатель на первый элемент динамического массива-вектора
	                      , int number_psevdo)     // количество элементов в массиве-векторе
{
	int begin = 0;        // начало рассмотрения диапазона гистограммы                         
	int end = 1;          // конец рассмотрения диапазона гистограммы
	int i;                // счётчик движения по массиву
	int chislo = 0;       // количество элементов, попавших в интервал
	double plus = begin;  // начало первого интервала
	double kol_vo_h;      // плотность частот
	double w = 0;         // относительные частоты
	double wi_h = 0;      // плотность относительных частот
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Относительная частота реализации w[i]- отношение числа случаев, в которых встретился данный результат,\n";
	cout << "к общему числу случаев : n[i] / n.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность относительных частот - относительная частота, рассчитанная на единицу ширины интервала: w[i]/h.\n";
	cout << "n[i] -количество вариант, попавших в текущий интервал\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Если варианта попадает на стык интервалов, то её следует относить в правый интервал.\n";
	cout << "Для всех интервалов, кроме последнего.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность частот - частота, рассчитанная на единицу ширины интервала: n[i]/h.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Относительная частота реализации w[i]- отношение числа случаев, в которых встретился данный результат,\n";
	cout << "к общему числу случаев : n[i] / n.\n";
	cout << "\x1b[31mОПРЕДЕЛЕНИЕ:\x1b[30m Плотность относительных частот - относительная частота, рассчитанная на единицу ширины интервала: w[i]/h.\n";
	k = 0;                // для движения по матрице
	// пока не дошли до конца интервала
	while (plus < end)
	{
		// движемся по массиву
		for (i = 0; i < number_psevdo; i++)
		{
			// считаем количество значений, попавших в интервал
			if (plus <= mass_raspr[i] && mass_raspr[i] < plus + step_ravnomerno)
			{
				chislo = chislo + 1;
			}// if
		}// for
		// запоминаем начало интервала в 0-ом стролбце матрицы k-ой строки
		ppMatrA[k][0] = plus;
		// запоминаем конец интервала в 1-ом столбце матрицы k-ой строки
		ppMatrA[k][1] = plus + step_ravnomerno;
		// запоминаем середину интервала в 2-ом столбце матрицы k-ой строки
		ppMatrA[k][2] = (ppMatrA[k][0] + ppMatrA[k][1]) / 2;
		// запоминаем количество элементов в интервале в 3-ом столбце матрицы k-ой строки
		ppMatrA[k][3] = chislo;
		// расчёт плотности частот как частное количества элементов, попавших в интервал и длины интервала
		kol_vo_h = chislo / step_ravnomerno;
		// запоминаем плотности частот элементов в интервале в 4-ом столбце матрицы k-ой строки
		ppMatrA[k][4] = kol_vo_h;
		// сдвигаемся на строку в матрице
		k = k + 1;
		// сдвигаемся на следующий интервал
		plus = plus + step_ravnomerno;
		// в новом интервале число элементов 0
		chislo = 0;
	}// while
	for (i = 0; i < k; i++)
	{
		// считаем относительные частоты
		w = ppMatrA[i][3] / number_psevdo;
		// помещаем их в пятый столбец матрицы
		ppMatrA[i][5] = w;
		// считаем плотность относительных частот
		wi_h = w / step_ravnomerno;
		// помещаем её в шестой столбец матрицы
		ppMatrA[i][6] = wi_h;
	}// for i;
	cout << "\n\x1b[34mСАМА МАТРИЦА:\x1b[30m\n\n";
	fout << "\nСАМА МАТРИЦА:\n\n";
	return;                        // заполнили матрицу - вернулись в caller
}// gistogramma_ravnomerno()


/*--------------------------------------------------------------------------*/
/* подсчёт моды выборки  */
/*-----------------------*/
void moda(double* ppMatrA[]             // указатель первого элемента матрицы указателей
	, int k                             // количество строк матрицы
	, int columns)                      // количество столбцов матрицы
{
	int i;                              // для прохода по матрице
	double max = ppMatrA[0][3];         // максимальная среди частот интервалов. Взяли пока первый интервал
	int index = 0;                      // индекс максимальной частоты
	int pred_int;                       // частота предыдущего интервала от максимального
	int sl_int;                         // частота следующего интервала от максимального
	double h;                           // длина модального интервала
	double moda;                        // само значение моды
	// идём по всем строкам матрицы, начиная со второй
	for (i = 1; i < k; i++) 
	{
		// если значение частоты в какой-либо строке больше запомненной
		if (ppMatrA[i][3] >= max)
		{
			max = ppMatrA[i][3];        // ставим это значение за max
			index = i;                  // запоминаем строку
		}// if (ppMatrA[i][3] >= max)
	}// for i
	// печать на экран и в файл вспомогательных значений
	cout << "X[0] = " << ppMatrA[index][0] << " - нижняя граница модального интервала\n";
	cout << "n[M] = " << max << " - частота модального интервала\n";
	fout << "X[0] = " << ppMatrA[index][0] << " - нижняя граница модального интервала\n";
	fout << "n[M] = " << max << " - частота модального интервала\n";
	// по запомненной строке находим длину модального интервала, обращаясь к соответствующим столбцам с началом и концом интервала
	h = ppMatrA[index][1] - ppMatrA[index][0];
	// если модальный интервал - первый
	if (index == 0)
	{
		// у первого интервала нет предыдущего
		pred_int = 0;
	}
	// иначе запоминаем его предка - интервал не первый
	else
	{	// запомнили частоту интервала, предыдущего модальному
		pred_int = ppMatrA[index - 1][3];
	}// if (index == 0)
	// вывели частоту предыдущего интервала на экран и в файл
	cout << "n[M-1] = " << pred_int << " - частота предыдущего интервала\n";
	fout << "n[M-1] = " << pred_int << " - частота предыдущего интервала\n";
	// если интервал последний - у него нет следующего за ним
	if (index == k - 1)
	{
		// у последнего интервала нет следующего
		sl_int = 0;
	}
	// иначе - интервал не последний. У него есть следующий за ним
	else
	{
		// запомнили частоту интервала, следующего за модальным
		sl_int = ppMatrA[index + 1][3];
	}// if (index == k - 1)
	// вывели частоту следующего интервала на экран и в файл
	cout << "n[M+1] = " << sl_int << " - частота следующего интервала\n";
	fout << "n[M+1] = " << sl_int << " - частота следующего интервала\n";
	// считаем значение моды по формуле
	moda = ppMatrA[index][0] + (((max - pred_int) * h) / ((max - pred_int) + (max - sl_int)));
	// печать на экран и в файл значения моды
	cout << "МОДА: " << moda<<";\n\n";
	fout << "МОДА: " << moda << ";\n\n";
	return;                             // вычислили моду - вернулись в caller
}// moda()


/*-----------------------------------------------------------*/
/* сортировка слиянием по возрастанию          */
/*---------------------------------------------*/
void Merge_sort_vozr(double* mass_raspr       // указатель на первый элемент динамического массива-вектора
	                  , int begin             // начало динамического массива-вектора
	                  , int end)              // конец динамического массива-вектора
	
{
	int middle;                            // отталкиваться будем от середины каждой части, разделяя массив на 2 подмассива
	// если осталось по одному элементу в каждом подмассиве
	// базовое условие
	if (begin >= end)
	{
		return;                            // вернулись на шаг назад в caller, где в рассматриваемой части 2 элемента минимум
	}// if(begin >= end)
	middle = (begin + end) / 2;            // вычислили средний элемент для текущего подмассива
	Merge_sort_vozr(mass_raspr, begin, middle);          // сортировка левой части
	Merge_sort_vozr(mass_raspr, middle + 1, end);        // сортировка правой части
	Merge_vozr(mass_raspr, begin, middle, end);          // слияние двух частей
}// Merge_sort_vozr()


/*----------------------------------------------------------------------------------*/
/* "Властвование" - сливание массивов для Merge_sort_vozr          */
/*-----------------------------------------------------------------*/
void Merge_vozr(double* mass_raspr         // указатель на первый элемент динамического массива-вектора
	          , int begin                  // начало динамического массива-вектора
	          , int middle                 // середина динамического массива-вектора
	          , int end)                   // конец динамического массива-вектора
{
	// соединение начинается с самых маленьких подмассивов в порядке рекурсии
	int i;                                 // для цикла
	int j = 0;                             // для цикла
	int k;                                 // для цикла
	int dlB = middle - begin + 1;          // длина левой части подмассива
	int dlC = end - middle;                // длина правой части подмассива
	double* B = NULL;                      // объявляем указатель на динамический массив элементов левой части. Инициализируем его, чтобы не был диким             
	B = new double[dlB + 1];               // создаём динамический подмассив, хранящий элементы левой части исходного
	double* C = NULL;                      // объявляем указатель на динамический массив элементов правой части. Инициализируем его, чтобы не был диким
	C = new double[dlC + 1];               // создаём динамический подмассив, хранящий элементы правой части исходного
	// заполняем левую часть
	// для B выделено j, т.к не обязательно begin=0
	for (i = begin; i <= middle; i++)
	{
		B[j] = mass_raspr[i];              // элемент левой части - элемент переданного подмассива 
		j++;                               // перемещаемся по подмассиву
	}// for i
	j = 0;                                 // обнулили счётчик для работы с подмассивом C

	// заполняем правую часть
	// для C выделено j, т.к  middle+1!=0
	for (i = middle + 1; i <= end; i++)
	{
		C[j] = mass_raspr[i];               // элемент правой части - элемент переданного подмассива 
		j++;                                // перемещаемся по подмассиву
	}// for i

	B[dlB] = DBL_MAX;                       // на последнее место каждого массива ставим заведомо больший элемент,
	C[dlC] = DBL_MAX;                       // чтобы не допускать выхода за пределы массива
	i = 0;                                  // ставим все счётчики в начало массивов
	j = 0;
	for (k = begin; k <= end; k++)          // идём по подмассиву
	{
		// выстраиваем иерархию элементов правой и левой части
		if (B[i] <= C[j])                   // если элемент правой части больше или равен элементу левой части 
		{
			mass_raspr[k] = B[i];           // помещаем элемент из левой части на текущее место подмассива
			i = i + 1;                      // перешли к следующему элементу левой части
			// если будет INT_MAX, то левая часть выходит из рассмотрения
		}
		else                                // если элемент левой части больше элемента правой части
		{
			mass_raspr[k] = C[j];           // помещаем элемент из правой части на текущее место подмассива
			j = j + 1;                      // перешли к следующему элементу правой части
			// если будет DBL, то правая часть выходит из рассмотрения
		}// if (B[i] <= C[j])
	}// for k
	delete[]B;                              // подмассивы отработаны - уничтожаем их
	delete[]C;
	return;                                 // вернули обещанное значение в caller
}// Merge_vozr()


/*---------------------------------------------------------------------*/
/* расчёт теоретической плотности нормального распределения */
/*----------------------------------------------------------*/
void teor_plotnost_norm(double vub_srednee      // рассчитанное выборочное среднее
	                  , double vub_disp         // рассчитанная выборочная дисперсия
	                  , int number_psevdo       // количество элементов в выборке
             	      , double* ppMatrA[]       // указатель первого элемента матрицы указателей
	                  , int k)                  // количество строк в матрице указателей
{
	cout << "\nТеоретические значения функции плотности нормального распределения по вычисленному выборочному среднему и выборочной дисперсии\n";
	double sigma = sqrt(vub_disp);              // стандартное отклонение
	cout << "Стандартное отклонение - корень из дисперсии, sigma = " << sigma << endl;
	cout<<"\x1b[31mЗАМЕЧАНИЕ:\x1b[30m Построение функции плотности распределения происходит через формулу функции плотности нормального\nраспределения\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Теоретические частоты вычисляются в середине каждого интервала гистограммы\n";
	// значение функции плотности распределения
	double znach1; 
	// теоретическая частота нормального распределения
	double n;
	// для движения по строкам матрицы
	int i;
	setlocale(0, "C");                          // отключаем русский язык
	// печатаем верхнюю часть шапки таблицы, которая включает значение середины интервала, значение функции плотности, теоретическую частоту
	cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196)<<(char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// печатаем заполнение шапки таблицы
	cout << "      X         " << (char)179 << "         f(X)         " << (char)179<<"         n(X)         ";
	// печатаем нижнюю часть шапки таблицы
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196)<<(char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// печатаем верхнюю часть шапки таблицы в файл
	fout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// печатаем заполнение шапки таблицы в файл
	fout << "      X         " << (char)179 << "         f(X)         " << (char)179 << "         n(X)         ";
	// печатаем нижнюю часть шапки таблицы в файл
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// считаем для середины каждого интервала
	for (i = 0; i < k; i++)
	{
		// вычисление значения функции плотности в середине каждого интервала
		znach1 = (1 / (sigma * sqrt(2 * PI))) * exp(-pow(ppMatrA[i][2] - vub_srednee, 2) / (2 * pow(sigma, 2)));
		// теоретическое значение частоты
		n = ((step * number_psevdo) / sigma) * znach1;
		// выводим значение элемента середины интервала, плотности распределения в этой точке и теоретической частоты на экран
		cout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][2] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((znach1) * 1000) / 1000 << setw(7) << setfill(' ')<<(char)179 << setw(16) << setfill(' ') << round((n) * 1000) / 1000 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице на экране
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196)<<(char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		// выводим значение элемента середины интервала, плотности распределения в этой точке и теоретической частоты в файл
		fout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][2] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((znach1) * 1000) / 1000 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((n) * 1000) / 1000 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице в файле
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	}// for i
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// teor_plotnost_norm()


/*----------------------------------------------------------------------------*/
/* расчёт теоретической плотности равномерного распределения */
/*-----------------------------------------------------------*/
void teor_plotnost_ravn(double vub_disp         // рассчитанная выборочная дисперсия
	                  , int number_psevdo       // количество элементов в выборке
	                  , double* ppMatrA[]       // указатель первого элемента матрицы указателей
	                  , int k)                  // количество строк в матрице указателей
{
	int a = 0;                                  // начало интервала
	int b = 1;                                  // конец интервала
	int i;                                      // для движения по матрице
	double sigma = sqrt(vub_disp);              // стандартное отклонение
	double znach1;                              // значение функции плотности
	double n;                                   // теоретическая частота
	cout << "\nТеоретические значения функции плотности равномерного распределения по формуле плотности нормального распределения\n";
	cout << "Стандартное отклонение - корень из дисперсии, sigma = " << sigma << endl;
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Теоретические частоты вычисляются в середине каждого интервала гистограммы и добавляются\nвычисления в 0 и 1. Для равномерного распределения теоретическая частота вычисляется путём деления размера выборки\nна количество интервалов\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Проверку на соответствие суммы теоретических частот общему количеству элементов осуществлять суммой\nзначений, вычисленных только в середине интервалов\n";
	setlocale(0, "C");              // отключаем русский язык
	// печатаем верхнюю часть шапки таблицы, которая включает значение середины интервала, значение функции плотности, теоретическую частоту
	cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// печатаем заполнение шапки таблицы
	cout << "      X         " << (char)179 << "         f(X)         " << (char)179 << "         n(X)         ";
	// печатаем нижнюю часть шапки таблицы
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// печатаем верхнюю часть шапки таблицы в файл
	fout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// печатаем заполнение шапки таблицы в файл
	fout << "      X         " << (char)179 << "         f(X)         " << (char)179 << "         n(X)         ";
	// печатаем нижнюю часть шапки таблицы в файл
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// печатаем строку под очередным выводом в таблице
	znach1 = (1 / (b - a));
	// расчёт теоретической частоты равномерного распределения
	n = (number_psevdo / double(k));
	// вычисления в 0 совпадают с любым значение теоретической частоты в середине любого промежутка
	// выводим значения в 0 на экран и в файл
	cout << (char)179 << setw(14) << setfill(' ') << "0" << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << znach1 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << n << setw(7) << setfill(' ');
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	fout << (char)179 << setw(14) << setfill(' ') << "0" << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << znach1 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << n << setw(7) << setfill(' ');
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// идём по всем элементам массива
	for (i = 0; i < k; i++)
	{
		// считаем значение плотности по формуле для нормального распределения
		znach1 = (1 / (b - a));
		// теоретическая частота для равномерного распределения
		n =( number_psevdo / double(k));
		// значение выборки не попадает в интервал
		if (ppMatrA[i][0]<a && ppMatrA[i][0] > b)
		{
			// значение функции плотности и теоретическая частота равны 0
			cout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][0] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
			cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196)<< (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
			fout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][0] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
			fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		}
		// значение выборки попадает в интервал
		else if (a <= ppMatrA[i][0] && ppMatrA[i][0] <= b)
		{// печатаем ранее вычисленное значение функции и теоретическую частоту
			cout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][2] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((znach1) * 1000) / 1000 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((n) * 1000) / 1000 << setw(7) << setfill(' ');
			cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
			fout << (char)179 << setw(14) << setfill(' ') << ppMatrA[i][2] << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((znach1) * 1000) / 1000 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round((n) * 1000) / 1000 << setw(7) << setfill(' ');
			fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		}// if
	}// for i
	// вычисление функции плотности в 1. Значение совпадает со значениями, вычисленными ранее
	cout << (char)179 << setw(14) << setfill(' ') << "1" << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << znach1 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << n << setw(7) << setfill(' ');
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	fout << (char)179 << setw(14) << setfill(' ') << "1" << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << znach1 << setw(7) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << n << setw(7) << setfill(' ');
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// teor_plotnost_ravn()


/*----------------------------------------------------------------------------*/
/* расчет функции псевдослучайных процессов */
/*------------------------------------------*/
void pract_raspr(double* ppMatrA[]      // указатель первого элемента матрицы указателей
   	           , int k)                 // количество строк в матрице указателей
{
	cout << "Построение эмперической функции распределения\n";
	cout << "\x1b[31mПРАВИЛО:\x1b[30m Значения формируются вида (x[прав]; w[i]), где w[i] -относительная частота, которая успела накопиться\nна всех пройденных интервалах\n";
	int i ;                             // для движения по матрице
	double x = ppMatrA[0][0] - 1;       // начинаем чуть раньше, чем начинается 1-ый интервал
	double w_n = 0;                     // относительные частоты для очередного значения функции распределения
	setlocale(0, "C");                  // отключаем русский язык
	// печать верхней строки шапки таблицы
	cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	cout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	fout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	fout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы в файл
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// проходим по части, где функция распределения равна 0;
	while (x < ppMatrA[0][1])
	{
		// выводим значение x и функции распределения, которое равно 0
		cout << (char)179 << setw(14) << setfill(' ')<< x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		// сдвигаем x
		x = x + step;
	}// while
	// далее идём по всем строкам матрицы
	for (i = 0; i < k; i++)
	{
		// запоминаем конец очередного интервала гистограммы
		x = ppMatrA[i][1];
		// накапливаем относительные частоты
		w_n = w_n + ppMatrA[i][5];
		// печатаем значения x и w_n на экран и в файл
		cout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 100) / 100 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 100) / 100 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	}
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// pract_raspr()


/*----------------------------------------------------------------------------*/
/* расчет теоретической функции гауссовского процесса */
/*----------------------------------------------------*/
void teor_raspr_norm(double vub_srednee // рассчитанное выборочное среднее
	               , double vub_disp    // рассчитанная выборочная дисперсия
	               , double* ppMatrA[]  // указатель первого элемента матрицы указателей
	               , int k)             // количество строк в матрице указателей
{
	int i;                          // для прохода по матрице
	double x = ppMatrA[0][0] - 1;   // начинаем чуть раньше, чем начинается 1-ый интервал
	double w_n = 0;                 // относительные частоты для очередного значения функции распределения
	setlocale(0, "C");              // отключаем русский язык
	// печать на экран и в файл
	cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	cout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	fout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	fout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// проходим по части, где функция распределения равна 0;
	while (x < ppMatrA[0][1])
	{
		// выводим значение x и функции распределения, которое равно 0
		cout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		// сдвигаем x
		x = x + step;
	}// while
	// далее идём по всем строкам матрицы
	for (i = 0; i < k; i++)
	{
		// запоминаем конец очередного интервала гистограммы
		x = ppMatrA[i][1];
		// вычисляем значение относительной частоты по формуле для нормального распределения
		w_n = 0.5*(1 + erf((x - vub_srednee)/sqrt(2*vub_disp)));
		// печатаем значения на экран и в файл
		cout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 100) / 100 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 100) / 100 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	}// for i
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// teor_raspr_norm()


/*----------------------------------------------------------------------------*/
/* расчет теоретической функции равномерного процесса */
/*----------------------------------------------------*/
void teor_raspr_ravnom(double* ppMatrA[]        // указатель первого элемента матрицы указателей
	                 , int k)                   // количество строк в матрице указателей
{
	int a = 0;                      // начало интервала
	int b = 1;                      // конец интервала
	int i;                          // для движения по строкам матрицы
	double x = ppMatrA[0][0] - 1;   // начинаем чуть раньше, чем начинается 1-ый интервал
	double w_n = 0;                 // относительные частоты для очередного значения функции распределения
	setlocale(0, "C");              // отключаем русский язык
	// печать на экран и в файл
	cout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	cout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы
	cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	fout << char(218) << setw(17) << setfill((char)196) << (char)194 << setw(23) << setfill((char)196) << (char)191 << endl << (char)179;
	// заполнение шапки таблицы включает правое значение интервала и значение функции распределения
	fout << "      X         " << (char)179 << "        F(X)          ";
	// печатаем нижнюю часть шапки таблицы
	fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	// проходим по части, где функция распределения равна 0;
	while (x < ppMatrA[0][1])
	{
		// выводим значение x и функции распределения, которое равно 0
		cout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << '0' << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		// сдвигаем x
		x = x + step;
	}// while
	// далее идём по всем строкам матрицы
	for (i = 0; i < k; i++)
	{
		// запоминаем конец очередного интервала гистограммы
		x = ppMatrA[i][1];
		// вычисляем значение относительной частоты по формуле для нормального распределения
		w_n = (x - a)/(b-a);
		// печатаем значения на экран и в файл
		cout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 1000) / 1000 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		cout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
		fout << (char)179 << setw(14) << setfill(' ') << x << setw(3) << setfill(' ') << (char)179 << setw(16) << setfill(' ') << round(w_n * 100) / 100 << setw(7) << setfill(' ');
		// печатаем строку под очередным выводом в таблице
		fout << (char)179 << endl << (char)195 << setw(17) << setfill((char)196) << (char)197 << setw(23) << setfill((char)196) << (char)180 << endl;
	}// for i
	setlocale(LC_ALL, "Rus");       // подключаем русский язык
	return;                         // вернули обещанное значение в caller
}// teor_raspr_ravnom()